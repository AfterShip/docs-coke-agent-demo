### 🔄 项目感知与上下文
- **在新对话开始时，总是阅读 `Planning.md`** 以了解项目的架构、目标、风格和约束。
- **开始新任务前检查 `TASK.md`**。如果任务不在列表中，请添加简要描述和今天的日期。
- **使用一致的命名约定、文件结构和架构模式**，如 `Planning.md` 中所述。
- **使用 Go 模块** (`go mod`) 进行依赖管理，确保 `go.mod` 和 `go.sum` 得到正确维护。

### 🧱 代码结构与模块化
- **永远不要创建超过 500 行代码的文件。** 如果文件接近此限制，请通过拆分为包或辅助文件进行重构。
- **使用清晰、一致的导入**（分组标准库、第三方和本地导入）。
- **遵循 Go 包命名约定**（小写、单个单词、描述性）。

### 🧪 测试驱动开发 (TDD)
#### 核心原则
- **采用测试驱动开发**，严格按以下流程工作：
	- **第一步：编写测试** - 基于需求和输入/输出对，编写完整测试用例（单元、集成、端到端），遵循领域模型设计，不要写任何实现代码，即使功能不存在也不要创建mock。
	- **第二步：验证失败** - 运行测试确认它们都失败了，展示失败输出，验证失败原因符合预期（缺少实现而非测试错误），这个阶段不要编写实现代码。
	- **第三步：提交确认** - 提供测试提交预览（文件列表、用例总结、覆盖范围），等明确回复"确认提交测试"后再执行git提交。
	- **第四步：编写实现** - 不修改测试，基于领域模型架构编写最小实现使测试通过，持续迭代（编写代码→运行测试→调整代码→重新测试）直到所有测试通过，然后重构优化。

#### 测试实践
- **始终为新功能创建 Go 测试**（函数、结构体、处理器等），使用标准的 `testing` 包。
- **更新任何逻辑后**，检查是否需要更新现有单元测试。如果需要，请执行。
- **测试应与代码并存**，使用 `_test.go` 后缀或独立的测试包。
	- 至少包括：
		- 1 个预期使用测试（正常路径）
		- 1 个边界情况
		- 1 个失败情况
- **使用表驱动测试** 处理多个测试用例：
  ```go
  func TestFunction(t *testing.T) {
      tests := []struct {
          name     string
          input    InputType
          expected OutputType
          wantErr  bool
      }{
          // 测试用例
      }
      for _, tt := range tests {
          t.Run(tt.name, func(t *testing.T) {
              // 测试逻辑
          })
      }
  }
  ```

### ✅ 任务完成
- **完成任务后立即在 `TASK.md` 中标记已完成的任务**。
- 将开发过程中发现的新子任务或 TODO 添加到 `TASK.md` 的"工作中发现"部分。

### 📎 风格与约定
- **使用 Go** 作为主要语言。
- **遵循 Go 约定**：使用 `gofmt`、`golint` 和 `go vet` 进行代码格式化和检查。
- **使用结构体标签** 进行 JSON/XML 序列化和验证。
- **使用接口** 进行抽象和可测试性。
- **遵循 Go 命名约定**：
	- 导出标识符以大写字母开头
	- 多词名称使用驼峰命名法
	- 使用描述性名称（除非广泛理解，否则不使用缩写）
- **使用 `gin` 构建 HTTP API**
- **为每个导出的函数和类型编写注释**，使用 Go 文档约定：

### 🛠️ 错误处理
- **始终显式处理错误** - 永远不要用 `_` 忽略错误。
- **在适当时使用自定义错误类型** 以获得更好的错误处理。
- **使用上下文包装错误**，使用 `fmt.Errorf("context: %w", err)`。
- **将错误作为最后一个返回值返回**，遵循 Go 约定。

### 📚 文档与可解释性
- **当添加新功能、依赖项更改或设置步骤修改时，更新 `README.md`**。
- **注释非显而易见的代码**，确保中级 Go 开发者能够理解所有内容。
- **使用 Go 文档约定** 进行包和函数文档。
- 编写复杂逻辑时，**添加内联 `// 原因:` 注释** 解释为什么，而不仅仅是什么。

### 🧠 AI 行为规则
- **永远不要假设缺失的上下文。如果不确定，请提问。**
- **永远不要臆造库或函数** - 只使用已知的、经过验证的 Go 标准库包或成熟的第三方模块。
- **在代码或导入中引用之前，始终确认模块路径和包名称存在。**
- **除非明确指示或属于 `TASK.md` 中的任务，否则永远不要删除或覆盖现有代码。**
- **添加新依赖项后始终运行 `go mod tidy`。**
- **在 `go.mod` 中指定模块版本时使用语义版本控制。**

### 📝 日志记录
- **在关键逻辑地方必须添加日志记录**，包括但不限于：
	- 函数入口和出口
	- 错误处理
	- 重要业务逻辑节点
	- 外部服务调用
	- 数据库操作
- **优先使用工程现有的 logging 工具**，如果项目中已有日志库，必须使用现有工具。
- **如果项目中没有日志库，使用 `github.com/marmotedu/log`** 进行日志处理。
- **日志级别规范**：
	- `Debug` - 调试信息，仅在开发环境使用
	- `Info` - 一般信息，记录正常流程
	- `Warn` - 警告信息，不影响程序运行但需要注意
	- `Error` - 错误信息，程序出现错误但可以继续运行
	- `Fatal` - 致命错误，程序无法继续运行
- **日志格式要求**：
	- 包含时间戳、日志级别、调用位置
	- 使用结构化日志格式（JSON）
	- 敏感信息必须脱敏处理

### 🏗️ 构建与部署
- **必须创建 Makefile 文件**，所有构建和部署操作都通过 `make` 命令执行。
- **Makefile 应包含以下基本目标**：
	- `make build` - 编译应用程序
	- `make test` - 运行所有测试
	- `make lint` - 代码检查和格式化
	- `make clean` - 清理构建产物
	- `make docker` - 构建 Docker 镜像
	- `make deploy` - 部署应用程序
	- `make dev` - 启动开发环境
- **创建 Dockerfiles**，使用多阶段构建以优化镜像大小。
- **所有操作统一通过 make 命令管理**，提高开发效率和一致性。%
